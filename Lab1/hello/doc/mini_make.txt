   Makefile Mini HOWTO

	 Автор: Tedi Heriyanto
         Все права в отношении данного документа принадлежат автору.
                       © 2002 Андрей Киселёв <kis_an@mail.ru> Перевод.


   Эта статья представляет собой небольшое руководство по созданию
   Makefile-ов. В ней объясняется для чего нужен Makefile и дается
   несколько правил, которых следует придерживаться при его создании.

   Введение

   Допустим, вы разрабатываете некую программу под названием foo,
   состоящую из пяти заголовочных файлов -- 1.h, 2.h, 3.h, 4.h и -- 5.h,
   и шести файлов с исходным текстом программы на языке С -- 1.cpp,
   2.cpp, 3.cpp, 4.cpp, 5.cpp и main.cpp. (Хочу заметить, что в реальных
   проектах следует избегать подобного стиля именования файлов).

   Теперь представим себе, что вы обнаружили ошибку в файле 2.cpp и
   исправили ее. Далее, чтобы получить исправленную версию программы вы
   компилируете все файлы, входящие в состав проекта, хотя изменения
   коснулись только одного файла. Это приводит к нерациональной потере
   времени, особенно если компьютер не слишком быстрый.

   Существует ли решение проблемы?

   Не стоит беспокоиться, друзья мои! Эта проблема уже давно решена.
   Опытными программистами была разработана утилита make. Вместо того,
   чтобы производить повторную компиляцию всех файлов с исходными
   текстами, она обрабатывает только те файлы, которые претерпели
   изменения. В нашем случае будет скомпилирован только один файл -
   2.cpp. Разве это не здорово!?

   Кроме того [2]:

   Утилита make значительно упрощает жизнь, когда для сборки проекта
   необходимо выполнение длинных и сложных команд. Проект иногда требует
   задания редко используемых, а потому сложных для запоминания опций
   компилятора. make избавит вас от необходимости удерживать их в памяти.
   Единообразие, т.к. работа с этой утилитой поддерживается многими
   средами разработки. Процесс сборки можно автоматизировать, поскольку
   make может быть вызвана из сценариев или из cron.

   Для чего нужен Makefile?

   Несмотря на все свои достоинства, утилита make ничего не знает о нашем
   проекте, поэтому необходимо создать простой текстовый файл, который
   будет содержать все необходимые инструкции по сборке. Файл с
   инструкциями по сборке проекта называется makefile (произносится как
   "мэйкфайл". прим. перев.).

   Как правило этим файлам дается имя makefile или Makefile, в
   соответствии с соглашениями по именованию таких файлов. Если же вы
   дадите файлу инструкций другое имя, то вам потребуется вызывать
   утилиту make с ключом -f.

   Например, если свой makefile вы назвали bejo, то команда на сборку
   проекта будет выглядеть так:

     make -f bejo

   Структура файла

   Makefile содержит разделы для "целей" [targets], зависимостей
   [dependencies] и правил (rules) сборки. Все это оформляется следующим
   образом: сначала указывается имя цели (обычно это имя исполняемого или
   объектного файла), после которого следует двоеточие, затем следуют
   имена зависимостей, т.е. файлов, необходимых для получения данной
   цели. И, наконец, следует список правил: т.е. команд, которые
   необходимо выполнить для получения указанной цели.

   Простой пример структуры makefile'а:

     target: dependencies
             command
             command
             ...

   Каждое правило command должно начинаться с символа табуляции -- это
   обязательное условие! Отсутствие символа табуляции в начале строки с
   правилом -- самая распространенная ошибка. К счастью, подобные ошибки
   легко обнаруживаются, так как утилита make сообщает о них.

   Пример Makefile

   Ниже приводится простой пример (номера строк добавлены для ясности).

     1 client: conn.o
     2    g++ client.cpp conn.o -o client
     3 conn.o: conn.cpp conn.h
     4    g++ -c conn.cpp -o conn.o

   В этом примере строка, содержащая текст client: conn.o, называется
   "строкой зависимостей", а строка g++ client.cpp conn.o -o client
   называется "правилом" и описывает действие, которое необходимо
   выполнить.

   А теперь более подробно о примере, приведенном выше:
     * Задается цель -- исполняемый файл client, который зависит от
       объектоного файла conn.o;
     * Правило для сборки данной цели;
     * В третьей строке задается цель conn.o и файлы, от которых она
       зависит -- conn.cpp и conn.h;
     * В четвертой строке описывается действие по сборке цели conn.o.

   Комментарии

   Строки, начинающиеся с символа "#", являются комментариями.

   Ниже приводится пример makefile с комментариями:

     1 # Создать исполняемый файл "client"
     2 client: conn.o
     3    g++ client.cpp conn.o -o client
     4
     5 # Создать объектный файл "conn.o"
     6 conn.o: conn.cpp conn.h
     7    g++ -c conn.cpp -o conn.o

   "Ложная" цель[1]

   Обычно "ложные" [phony] цели, представляющие "мнимое" имя целевого
   файла, используются в случае возникновения конфликтов между именами
   целей и именами файлов при явном задании имени цели в командной
   строке.

   Допустим в makefile имеется правило, которое не создает ничего,
   например:

     clean:
             rm *.o temp

   Поскольку команда rm не создает файл с именем clean, то такого файла
   никогда не будет существовать и поэтому команда make clean всегда
   будет отрабатывать.

   Однако, данное правило не будет работать, если в текущем каталоге
   будет существовать файл с именем clean. Поскольку цель clean не имеет
   зависимостей, то она никогда не будет считаться устаревшей и,
   соответственно, команда 'rm *.o temp' никогда не будет выполнена. (при
   запуске make проверяет даты модификации целевого файла и тех файлов,
   от которых он зависит. И если цель оказывается "старше", то make
   выполняет соответствующие команды-правила -- прим. ред.) Для
   устранения подобных проблем и предназначена специальная декларация
   .PHONY, объявляющая "ложную" цель. Например:

     .PHONY : clean

   Таким образом мы указываем необходимость исполнения цели, при явном ее
   указании, в виде make clean вне зависимости от того -- существует файл
   с таким именем или нет.

   Переменные

   Определить переменную в makefile вы можете следующим образом:

     $VAR_NAME=value

   В соответствии с соглашениями имена переменных задаются в верхнем
   регистре:

     $OBJECTS=main.o test.o

   Чтобы получить значение переменной, необходимо ее имя заключить в
   круглые скобки и перед ними поставить символ '$', например:

     $(VAR_NAME)

   В makefile-ах существует два типа переменных: "упрощенно вычисляемые"
   и "рекурсивно вычисляемые".

   В рекурсивно вычисляемых переменных все ссылки на другие переменные
   будут замещены их значениями, например:

     TOPDIR=/home/tedi/project
     SRCDIR=$(TOPDIR)/src

   При обращении к переменной SRCDIR вы получите значение
   /home/tedi/project/src.

   Однако рекурсивные переменные могут быть вычислены не всегда, например
   следующие определения:

     CC = gcc -o
     CC = $(CC) -O2

   выльются в бесконечный цикл. Для разрешения этой проблемы следует
   использовать "упрощенно вычисляемые" переменные:

     CC := gcc -o
     CC += $(CC) -O2

   Где символ ':=' создает переменную CC и присваивает ей значение "gcc
   -o". А символ '+=' добавляет "-O2" к значению переменной CC.

   Заключение

   Я надеюсь, что это краткое руководство содержит достаточно информации,
   чтобы начать создавать свои makefile. А за сим -- успехов в работе.

   Библиография

   1 GNU Make Documentation File, info make.
   2 Kurt Wall, et.al., Linux Programming Unleashed (Программирование под
   Linux на оперативном просторе -- прим. ред.), 2001.

